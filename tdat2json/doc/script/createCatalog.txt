// this is going to have to be run on a 64-bit server, there doesn't seem to be a way to make this work in 32-bit

// set necessary Array functions
Array.prototype.unique = function(b) {
    var a = [], i, l = this.length;
    for (i = 0; i < l; i++) {
        if (a.indexOf(this[i], 0, b) < 0) {
            a.push(this[i]);
        }
    }
    return a;
};

Array.prototype.remove = function(from, to) {
    var rest = this.slice((to || from) + 1 || this.length);
    this.length = from < 0 ? this.length + from : from;
    return this.push.apply(this, rest);
};

Array.prototype.containsPattern = function(pattern) {
    // if we don't return a pattern, result is false
    if (pattern == null) {
        return false;
    }
    // if we have an empty or null array, return false
    if (this.length == 0 || this == null) {
        return false;
    }
    // if this isn't an array, return false
    if (!(this instanceof Array)) {
        return false;
    }
    //loop through the values to see if we get a match. checkMe is a boolean that is true if match returns
    // something, but by default
    var checkMe = false;

    for (var i = 0; i < this.length; i++) {
        var newString = new String(this[i]);
        if (newString.search(pattern) != -1) {
            checkMe = true;
            break;
        }
    }

    return checkMe;
}

// add the empty xref array to all records.
db.catalog.update({}, {$set:{"xref":[]}}, false, true);

// add the dbref field to all records.
db.catalog.update({}, {$set:{"dbref":[]}},false, true);

// add the mediaref field to all records
db.catalog.update({},{$set:{"mediaref":[]}},false, true);

// populate the xref array
db.catalog.find().forEach(function(obj) {
    // star catalogs
    if (obj.bscname != null) {
        obj.xref.push(obj.bscname);
    }
    if (obj.cpdname != null) {
        obj.xref.push(obj.cpdname);
    }
    if (obj.dmname != null) {
        obj.xref.push(obj.dmname);
    }
    if (obj.gcname != null) {
        obj.xref.push(obj.gcname);
    }
    if (obj.gliesename != null) {
        obj.xref.push(obj.gliesename);
    }
    if (obj.hdname != null) {
        obj.xref.push(obj.hdname);
    }
    if (obj.hipname != null) {
        obj.xref.push(obj.hipname);
    }
    if (obj.ppmname != null) {
        obj.xref.push(obj.ppmname);
    }
    if (obj.saoname != null) {
        obj.xref.push(obj.saoname);
    }

    // galaxy catalogs
    if (obj.messiername != null) {
        obj.xref.push(obj.messiername);
    }
    if (obj.ngc2000name != null) {
        obj.xref.push(obj.ngc2000name);
    }
    if (obj.ugcname != null) {
        obj.xref.push(obj.ugcname);
    }
    db.catalog.save(obj);
});

function fixArray2() {
    var counter = 0;
    // I only want the xref for each field, I don't even want the id
    var cursor = db.catalog.find({}, {xref: true, _id: false});

    // I don't want to init this inside the loop, worried about memory leaks (probably baseless worry)
    var consolidatedArray = [];
    while (cursor.hasNext()) {
        var xref1 = cursor.next().xref;
        // first pass: create a consolidated array when the cross references match
        var limitedCursor1 = db.catalog.find({"name":{$in:xref1}});
        while (limitedCursor1.hasNext()) {
            var doc1 = limitedCursor1.next();
            consolidatedArray = consolidatedArray.concat(doc1.xref);
        }
        consolidatedArray = consolidatedArray.unique();
        // now that we have the consolidated array, reset the xref field of the object to it
        for (var i=0; i<consolidatedArray.length; i++) {
            db.catalog.update({name:consolidatedArray[i]},{$set:{xref: consolidatedArray}},false, true);
        }

        consolidatedArray.length = 0;

        counter++;
        if (counter % 10000 == 0) {
            print("Processed " + counter + " documents.");
        }
    }
}

fixArray2();



// cns3 catalog
db.cn3s.ensureIndex({name:1});
db.cns3.find().forEach(function(obj) {
    var ref = db.catalog.findOne({name:obj.name});
    ref.dbref.push(new DBRef("cns3", obj._id);
    db.catalog.save(ref);
}